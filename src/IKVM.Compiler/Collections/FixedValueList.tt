<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".g.cs" #>
#nullable disable

using System;
using System.Collections;
using System.Collections.Generic;

using IKVM.Compiler.Managed;

namespace IKVM.Compiler.Collections
{
<#
foreach (var size in new[]
{
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8
})
{
#>

    public static partial class ReadOnlyFixedValueList
    {

        /// <summary>
        /// Gets the item at the specified index.
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public static ref readonly T GetItemRef<T>(this in ReadOnlyFixedValueList<#= size #><T> self, int index)
        {
            switch (index)
            {
                case 0:
                    return ref self.list.item0;
                default:
                    return ref self.list.more![index - 1];
            }
        }

    }

    /// <summary>
    /// A fixed structural <see cref="IReadOnlyList{T}"/> implementation that optimizes for short lists.
    /// </summary>
    /// <typeparam name="TList"></typeparam>
    public readonly struct ReadOnlyFixedValueList<#= size #><T>
    {

        /// <summary>
        /// Returns an empty list.
        /// </summary>
        public static readonly ReadOnlyFixedValueList<#= size #><T> Empty = new ReadOnlyFixedValueList<#= size #><T>();

        internal readonly FixedValueList<#= size #><T> list;

        /// <summary>
        /// Initializes a new instance.
        /// </summary>
        /// <param name="list"></param>
        public ReadOnlyFixedValueList<#= size #>(in FixedValueList<#= size #><T> list)
        {
            this.list = list;
        }

        /// <summary>
        /// Gets the item at the specified index.
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public readonly T this[int index] => list[index];

        /// <summary>
        /// Gets the number of items in the list.
        /// </summary>
        public readonly int Count => list.Count;

    }

    public static partial class FixedValueList
    {

        /// <summary>
        /// Gets the item at the specified index.
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public static ref readonly T GetItemRef<T>(this in FixedValueList<#= size #><T> self, int index)
        {
            switch (index)
            {
                case 0:
                    return ref self.item0;
                default:
                    return ref self.more![index - 1];
            }
        }

    }

    /// <summary>
    /// A fixed structural list implementation that optimizes for lists up to <#= size #> items.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public partial struct FixedValueList<#= size #><T>
    {

        internal readonly int count;
<#
    for (int i = 0; i < size; i++)
    {
#>
        internal T item<#= i #> = default;
<#
    }
#>
        internal readonly T[] more;

        /// <summary>
        /// Initializes a new instance.
        /// </summary>
        /// <param name="count"></param>
        public FixedValueList<#= size #>(int count)
        {
            if (count < 0)
                throw new ArgumentOutOfRangeException(nameof(count));

            this.count = count;

            if (count > <#= size #>)
            {
                var size = count - <#= size #>;
                more = new T[(size + (size - 1)) & -size];
            }
        }

        /// <summary>
        /// Initializes a new instance.
        /// </summary>
        /// <param name="source"></param>
        public FixedValueList<#= size #>(ReadOnlySpan<T> source) :
            this(source.Length, source)
        {

        }

        /// <summary>
        /// Initializes a new instance.
        /// </summary>
        /// <param name="count"></param>
        /// <param name="source"></param>
        public FixedValueList<#= size #>(int count, ReadOnlySpan<T> source) :
            this(count)
        {
<#
    for (int i = 0; i < size; i++)
    {
#>
            if (this.count > <#= i #>)
                item<#= i #> = source[<#= i #>];
<#
    }
#>

            if (this.count > <#= size #>)
            {
                var s = this.count - <#= size #>;
                for (int i = 0; i < s; i++)
                    more[i] = source[i + <#= size #>];
            }
        }

        /// <summary>
        /// Initializes a new instance.
        /// </summary>
        /// <param name="source"></param>
        public FixedValueList<#= size #>(in FixedValueList<#= size #><T> source) :
            this(source.Count, source)
        {

        }

        /// <summary>
        /// Initializes a new instance.
        /// </summary>
        /// <param name="count"></param>
        /// <param name="source"></param>
        public FixedValueList<#= size #>(int count, in FixedValueList<#= size #><T> source) :
            this(count)
        {
<#
    for (int i = 0; i < size; i++)
    {
#>
            item<#= i #> = source.item<#= i #>;
<#
    }
#>
            source.more?.AsSpan(0, Math.Min(source.more.Length, count - <#= size #>)).CopyTo(more);
        }

        /// <summary>
        /// Initializes a new instance.
        /// </summary>
        /// <param name="source"></param>
        public FixedValueList<#= size #>(in ReadOnlyFixedValueList<#= size #><T> source) :
            this(source.Count, source)
        {

        }

        /// <summary>
        /// Initializes a new instance.
        /// </summary>
        /// <param name="count"></param>
        /// <param name="source"></param>
        public FixedValueList<#= size #>(int count, in ReadOnlyFixedValueList<#= size #><T> source) :
            this(count)
        {
<#
    for (int i = 0; i < size; i++)
    {
#>
            item<#= i #> = source.list.item<#= i #>;
<#
    }
#>
            source.list.more?.AsSpan(0, Math.Min(source.list.more.Length, count - <#= size #>)).CopyTo(more);
        }

        /// <summary>
        /// Initializes a new instance.
        /// </summary>
        /// <param name="source"></param>
        public FixedValueList<#= size #>(IList<T> source) :
            this(source.Count)
        {
<#
    for (int i = 0; i < size; i++)
    {
#>
            if (this.count > <#= i #>)
                item<#= i #> = source[<#= i #>];
<#
    }
#>

            if (this.count > <#= size #>)
            {
                var s = this.count - <#= size #>;
                for (int i = 0; i < s; i++)
                    more[i] = source[i + <#= size #>];
            }
        }

        /// <summary>
        /// Initializes a new instance.
        /// </summary>
        /// <param name="source"></param>
        public FixedValueList<#= size #>(T[] source) :
            this(source.Length)
        {
<#
    for (int i = 0; i < size; i++)
    {
#>
            if (this.count > <#= i #>)
                item<#= i #> = source[<#= i #>];
<#
    }
#>

            if (this.count > <#= size #>)
            {
                var s = this.count - <#= size #>;
                for (int i = 0; i < s; i++)
                    more[i] = source[i + <#= size #>];
            }
        }

        /// <summary>
        /// Initializes a new instance.
        /// </summary>
        /// <param name="source"></param>
        public FixedValueList<#= size #>(IReadOnlyList<T> source) :
            this(source.Count)
        {
<#
    for (int i = 0; i < size; i++)
    {
#>
            if (this.count > <#= i #>)
                item<#= i #> = source[<#= i #>];
<#
    }
#>

            if (this.count > <#= size #>)
            {
                var s = this.count - <#= size #>;
                for (int i = 0; i < s; i++)
                    more[i] = source[i + <#= size #>];
            }
        }

        /// <summary>
        /// Gets or sets the item at the specified index.
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public T this[int index]
        {
            readonly get => GetItem(index);
            set => SetItem(index, value);
        }

        /// <summary>
        /// Gets the item at the specified index.
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        readonly T GetItem(int index)
        {
            switch (index)
            {
<#
    for (int i = size - 1; i >= 0; i--)
    {
#>
                case <#= i #>:
                    return item<#= i #>;
<#
    }
#>
                default:
                    return more![index - <#= size #>];
            }
        }

        /// <summary>
        /// Sets the item at the specified index.
        /// </summary>
        /// <param name="index"></param>
        /// <param name="value"></param>
        /// <exception cref="IndexOutOfRangeException"></exception>
        void SetItem(int index, T value)
        {
            switch (index)
            {
<#
    for (int i = size - 1; i >= 0; i--)
    {
#>
                case <#= i #>:
                    item<#= i #> = value;
                    break;
<#
    }
#>
                default:
                    more![index - <#= size #>] = value;
                    break;
            }
        }

        /// <summary>
        /// Gets the number of items in the list.
        /// </summary>
        public readonly int Count => count;

        /// <summary>
        /// Initializes a new instance.
        /// </summary>
        /// <returns></returns>
        public ReadOnlyFixedValueList<#= size #><T> AsReadOnly()
        {
            return new ReadOnlyFixedValueList<#= size #><T>(this);
        }

    }
<#
}
#>

}
